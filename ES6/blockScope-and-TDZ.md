# 區塊作用域 (block scope) 和 暫時性死區 (temporal dead zone)

## 前言
在 ES6 之前，JS 只有**全局作用域**和**函數作用域**，而在 ES6 新增 `let`、`const` 後，帶來了新的特性，也就是今天要提到的**區塊作用域**和**暫時性死區**。

如果你還不清楚 `let`、`const` 和 `var` 的差別，可以先閱讀這篇文章喔。

[ES6 中 let、const 和 var 的差異](https://thisweb.tech/js-var-let-const/)

## 甚麼是作用域 scope
首先，先來看一下作用域是什麼意思，

我覺得作用域就像是一個單向房間，在這個房間裡的人，只能拿到房間**內部**和**外部**的物品。

全局作用域就是最外層的房間，每個人都在這個大房間裡面，所以所有人都可以拿到全局作用域的變數；函數作用域就是一個個小房間，外面的人就拿不到裡面的變數，比如說：

```js
const a = 1;

console.log(a); // 1

function f() {
  const b = 2;
  console.log(a, b) // 1, 2
}

for (let i = 0; i < 3; i++) {
  console.log(a) // 1
}

console.log(b) // 錯誤
```
`a` 這個變數存在於全局作用域，所以它在任何地方都可以被讀取到，不管是函數還是迴圈。

而 `b` 因為只在函數作用域裡面，所以在作用域外部就沒辦法取得到它。


## 全局 / 函數作用域的問題
上面說在 ES6 之前，只有**全局作用域**和**函數作用域**，這其實非常不方便，比如：
```js
var a = 1;

function f() {
  if (false) {
    var a = 2;
  }

  console.log(a);
}

f() // undefined
```
我們預期結果應該要是 1，但卻是 `undefined`，這是因為
1. `var` 會變數提升到作用域頂部
2. `var` 只有全局作用域和函數作用域
 
所以它會變成下面的程式碼：
```js
function f() {
  var a;

  if (false) {
    a = 2;
  }

  console.log(a); // undefined
}
```

還有：
```js
for (var i = 0; i < s.length; i++) {
  console.log(i);
}

console.log(i); // 5
```
迴圈外部也能讀取到變數 `i`，這都是因為沒有**區塊作用域**導致的後果。

## 區塊作用域
到了 ES6，有了 `let`、`const` 後，每一個大括號 `{}` 就是一個房間，也就是一個區塊，比如說：

```js
let a = 1;

function f() {
  if (false) {
    let a = 2;
  }
  console.log(a) // 1
}
```
結果正常多了，因為 `if` 區塊作用域外部，拿不到內部的變數，所以只好往外拿全局作用域的 `a`。

## 暫時性死區 temporal dead zone
當區塊作用域裡面有 `let`，它宣告的變數就會綁定在這個區塊內，不受外部的影響，比如說：
```js
var a = 1;

if (true) {
  a = 2; // // ReferenceError
  let a;
}
```
上面的程式碼存在全局變數 `a`，但是區塊作用域內 `let` 又宣告一個局部變數 `a`，導致後者綁定這個區塊作用域，所以 `let` 宣告變數前，對 `a` 賦值會報錯。

也就是如果區塊內有 `let`、`const` 宣告的變數，那在這個區塊內，只要先賦值給這些變數就會錯誤，形成暫時性死區：
```js
if (true) {

  // 前面這裡都不能對 a 操作，暫時性死區

  let a;

  // 後面就都可以了
}
```

## 結尾
ES6 出現 `let`、`const` 而帶來的暫時性死區、區塊作用域，在新手一開始接觸時可能會覺得很複雜，又不好用，但這樣嚴謹的設定，才能減少預料之外的錯誤，比如上面提到函數作用域的問題。

總而言之，記得三件事情就好
1. 不要用 `var`
2. 作用域外部拿不到內部的值
3. 宣告變數前不能使用它
